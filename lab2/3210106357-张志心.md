# Lab 2: RV64 内核线程调度

## 实验目的

* 了解线程概念，并学习线程相关结构体，并实现线程的初始化功能。
* 了解如何使用时钟中断来实现线程的调度。
* 了解线程切换原理，并实现线程的切换。
* 掌握简单的线程调度算法，并完成两种简单调度算法的实现。


## 实验环境

* Environment in previous labs

## 实验步骤

### 线程调度功能实现

#### 线程初始化

为线程分配一个 4kB 的物理页，将 `task_struct` 存放在该页的低地址部分，将线程的栈指针 `sp` 指向该页的高地址。

```c++
void task_init() {
    test_init(NR_TASKS);
    
    mm_init();
    idle = (struct task_struct *)kalloc();
    if(!idle) return;
    current = task[0] = idle;
    idle->state = TASK_RUNNING;
    idle->counter = 0;
    idle->priority = 0;
    idle->pid = 0;

    for(int i = 1; i < NR_TASKS; ++i) {
        task[i] = (struct task_struct *)kalloc();
        if(!task[i]) return;
        task[i]->state = TASK_RUNNING;
        task[i]->counter = task_test_counter[i];
        task[i]->priority = task_test_priority[i];
        task[i]->pid = i;
        task[i]->thread.ra = (uint64)__dummy;
        task[i]->thread.sp = PGSIZE + (long)task[i];
    }

    printk("...proc_init done!\n");
}
```

#### 在 `entry.S` 添加 `__dummy`

在`__dummy` 中将 sepc 设置为 `dummy()` 的地址，并使用 `sret` 从中断中返回。

```assembly
    .globl __dummy
__dummy:
    la t0, dummy
    csrw sepc, t0
    sret
```

#### 进程切换

判断下一个执行的线程 `next` 与当前的线程 `current` 是否为同一个线程，如果是同一个线程，则无需做任何处理，否则调用 `__switch_to` 进行线程切换。

```c++
void switch_to(struct task_struct* next) {
    if(!current) return;
    if(!next) return;
    if(current->pid != next->pid) {
        struct task_struct *prev = current;
        current = next;
        __switch_to(prev, next);
    }
}
```

在 `entry.S` 中实现线程上下文切换 `__switch_to`:

```assembly
.globl __switch_to
__switch_to:
    mv t0, a0
    mv t1, a1
    sd ra, 48(t0)
    sd sp, 56(t0)
    sd s0, 64(t0)
    sd s1, 72(t0)
    sd s2, 80(t0)
    sd s3, 88(t0)
    sd s4, 96(t0)
    sd s5, 104(t0)
    sd s6, 112(t0)
    sd s7, 120(t0)
    sd s8, 128(t0)
    sd s9, 136(t0)
    sd s10, 144(t0)
    sd s11, 152(t0)

    ld ra, 48(t1)
    ld sp, 56(t1)
    ld s0, 64(t1)
    ld s1, 72(t1)
    ld s2, 80(t1)
    ld s3, 88(t1)
    ld s4, 96(t1)
    ld s5, 104(t1)
    ld s6, 112(t1)
    ld s7, 120(t1)
    ld s8, 128(t1)
    ld s9, 136(t1)
    ld s10, 144(t1)
    ld s11, 152(t1)

    ret
```

#### 调度入口函数

在时钟中断处理函数中调用。

```c++
void do_timer(void) {
    if(!current) return;
    if(current->pid == 0) {
        schedule();
    }
    else {
        if(current->counter > 0) --current->counter;
        if(current->counter == 0) {
            current->state = !TASK_RUNNING;
            schedule();
        }
    }
}
```

#### 短作业优先调度算法

```c++
#ifdef DSJF
void schedule(void) {
    int next_id = -1;
    for(int i = 1; i < NR_TASKS; ++i) {
        if(task[i] && task[i]->counter > 0 && task[i]->state == TASK_RUNNING &&
            (next_id==-1 || task[i]->counter < task[next_id]->counter)) {
            next_id = i;
        }
    }
    if(~next_id) {
        printk("switch to [PID = %d COUNTER = %d]\n", next_id, task[next_id]->counter);
        switch_to(task[next_id]);
    } else {
        for(int i = 1; i < NR_TASKS; ++i) if(task[i]) {
            task[i]->state = TASK_RUNNING;
            task[i]->counter = rand();
            printk("SET [PID = %d COUNTER = %d]\n", i, task[i]->counter);
        }
        schedule();
    }
}
#endif
```

#### 优先级调度算法

```c++
#ifdef DPRIORITY
void schedule(void) {
    int next_id = -1;
    for(int i = 1; i < NR_TASKS; ++i) {
        if(task[i] && task[i]->counter > 0 && task[i]->state == TASK_RUNNING &&
            (next_id==-1 || task[i]->counter >= task[next_id]->counter)) {
            next_id = i;
        }
    }
    if(~next_id) {
        printk("switch to [PID = %d PRIORITY = %d COUNTER = %d]\n", next_id, task[next_id]->priority, task[next_id]->counter);
        switch_to(task[next_id]);
    } else {
        for(int i = 1; i < NR_TASKS; ++i) if (task[i]) {
            task[i]->state = TASK_RUNNING;
            task[i]->counter = task[i]->priority + 1;
            printk("SET [PID = %d PRIORITY = %d COUNTER = %d]\n", i, task[i]->priority, task[i]->counter);
        }
        schedule();
    }
}
#endif
```

### 运行效果

#### SJF 短作业优先调度

![image-20231108000747378](/Users/pac/Documents/2023-f/OS/OS2023-Autumn/lab2/assets/image-20231108000747378.png)

#### Priority 优先级调度

![image-20231108000643766](/Users/pac/Documents/2023-f/OS/OS2023-Autumn/lab2/assets/image-20231108000643766.png)

### 测试结果

#### SJF 短作业优先调度

![image-20231107230654885](/Users/pac/Documents/2023-f/OS/OS2023-Autumn/lab2/assets/image-20231107230654885.png)

#### Priority 优先级调度

![image-20231108000239895](/Users/pac/Documents/2023-f/OS/OS2023-Autumn/lab2/assets/image-20231108000239895.png)

### 思考题

1. 在 RV64 中一共用 32 个通用寄存器，为什么 `context_switch` 中只保存了14个?

   

2. 当线程第一次调用时，其 `ra` 所代表的返回点是 `__dummy`。那么在之后的线程调用中 `context_switch` 中，`ra` 保存/恢复的函数返回点是什么呢? 请同学用 gdb 尝试追踪一次完整的线程切换流程，并关注每一次 `ra` 的变换。

   
